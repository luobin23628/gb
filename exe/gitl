#!/usr/bin/env ruby

require 'gitl'
require 'command'
require 'gitlab'
require 'optparse'

Gitl::Command::run(ARGV)

#begin
options = {}
OptionParser.new do |opts|
  opts.banner = "usage: git clone [<options>] [--] <repo> [<dir>]"

  opts.separator ""
  opts.separator "Specific options:"

  opts.on("-p A,B", "--projects A,B", Array, "String") do |value|
    options[:projects] = value
  end

  opts.on("-m title", "--message Title", "title") do |value|
    options[:title] = value
  end

  opts.on("-s source", "--sourcebranch source") do |value|
    options[:source_branch] = value
  end

  opts.on("-t target", "--targetbranch target") do |value|
    options[:target_branch] = value
  end

  opts.on("-a assignee", "--assignee assignee") do |value|
    options[:assignee] = value
  end

  opts.separator ""
  opts.separator "Common options:"

  opts.on_tail("-h", "--help", "Show this message") do
    puts opts
    exit
  end

end.parse!

puts options

unless options[:source_branch]
  puts "fatal: You must specify source_branch."
  exit(false)
end

unless options[:target_branch]
  puts "fatal: You must specify target_branch."
  exit(false)
end

unless options[:title]
  puts "fatal: You must specify a title."
  exit(false)
end

unless options[:projects]
  puts "fatal: You must specify projects."
  exit(false)
end

# api: https://www.rubydoc.info/gems/gitlab/toplevel
# document: https://narkoz.github.io/gitlab/cli

# set an API endpoint
# API endpoint URL, default: ENV['GITLAB_API_ENDPOINT']
Gitlab.endpoint = 'http://git.tianxiao100.com/api/v4'
# => "https://example.net/api/v4"

# set a user private token
# user's private token or OAuth2 access token, default: ENV['GITLAB_API_PRIVATE_TOKEN']
Gitlab.private_token = '-A8bhPrhudHcnSkVGCZr'

user = nil
if options[:assignee]
  users = Gitlab.user_search(options[:assignee])
  if users.size > 1
    puts "Find more than one user. you means which one?"
    users.each do |user|
      print user.name + '  '
    end
    print "\n"
  elsif users.size == 1
    user = users[0]
    puts "Find user #{user.name}"
  else
    puts "Can't find user #{options[:assignee]}."
    exit(false)
  end
end

def create_merge_request(projectId, merge_title, source_branch, target_branch, assignee_id=0)
  begin
    Gitlab.create_merge_request(projectId, merge_title,
                                { source_branch: source_branch, target_branch: target_branch, assignee_id:assignee_id })
  rescue Gitlab::Error::Conflict => error
    # merge exists
    puts error
    return nil
  rescue Gitlab::Error::Error => error
    puts error
    return nil
  end
end

def branch_exist(projectId, branch)
  begin
    Gitlab.branch(projectId, branch)
    return true
  rescue Gitlab::Error::NotFound => error
    # merge not found
    puts error
    return false
  rescue Gitlab::Error::Error => error
    puts error
    return false
  end
end

options[:projects].each do |name|
  projects = Gitlab.project_search(name)
  if projects.size > 1
    puts "Find more than one users. you means which one?"
    projects.each do |project|
      print project.name + '  '
    end
    print "\n"
    exit(false)

  elsif projects.size == 1
    project = projects[0];
    puts "Find project #{project.name} on #{project.web_url}"

    unless branch_exist(project.id, options[:source_branch])
      puts "Can't find branch #{options[:source_branch]} in project #{project.name}."
      exit(false)
    end
    unless branch_exist(project.id, options[:target_branch])
      puts "Can't find branch #{options[:target_branch]} in project #{project.name}."
      exit(false)
    end

    compare_response = Gitlab.compare(project.id, options[:target_branch], options[:source_branch]);
    if compare_response.commits.size >= 1
      puts "\nCommits"
      compare_response.commits.each_with_index do |commit, index|
        unless index == 0
          puts ""
        end
        puts "  #{index} id:" + commit["id"]
        puts "  author:" + commit["author_name"]
        puts "  create at: " + commit["created_at"]
        puts "  title: " + commit["title"]

      end
      puts ""

    else
      puts "Can't find commit between #{options[:source_branch]} and #{options[:target_branch]} in project #{project.name}."
      next
    end

    if compare_response.diffs.size >= 1
      puts "Diffs"
      compare_response.diffs.each do |diff|
        if diff["new_file"]
          puts "  created " + diff["new_path"]
        elsif diff["renamed_file"]
          puts "  renamed " + diff["old_path"] + "=>" + diff["new_path"]
        elsif diff["deleted_file"]
          puts "  deleted" + diff["old_path"]
        else
          puts "  edited " + diff["new_path"]
        end

        diff = diff["diff"];
        lines = diff.split("\n")
        lines.each do |line|
          puts "  " + line
        end

      end
    else
      puts "Can't find diff between #{options[:source_branch]} and #{options[:target_branch]} in project #{project.name}."
      next
    end

    puts "\nContinue create merge request for #{project.name}? Y/N?"
    flag = gets.chomp
    unless flag.downcase == "y"
      exit
    end

    merge_request = create_merge_request(project.id, options[:title], options[:source_branch], options[:target_branch], user ? user.id : "")
    if merge_request
      puts "Create merge request for #{project.name} success. Detail url:#{merge_request.web_url}"
    else
      exit(false)
    end

  else
    puts "Can't find project #{name}, abort."
    exit(false)
  end
end

#end



